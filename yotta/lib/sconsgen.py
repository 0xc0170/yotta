# Copyright 2014 ARM Limited
#
# Licensed under the Apache License, Version 2.0
# See LICENSE file for details.

# standard library modules, , ,
import string
import os
import logging
import re
import itertools
from collections import defaultdict

# bsd licensed - pip install jinja2
from jinja2 import Environment, DictLoader

# fsutils, , misc filesystem utils, internal
import fsutils
# validate, , validate various things, internal
import validate

SCons_Template = '''
# NOTE: This file is generated by yotta: changes will be overwritten!
import os
{% if toplevel %}
import sys

# Target will define environment and will return it, plus the linker script
SConscript("{{ toolchain_file | replaceBackslashes }}")
Import('env link_script')
env['buildroot'] = "{{ build_dir }}"

def BuilddirObject(env, builddir, src):
    objname = os.path.splitext(os.path.basename(src))[0] + '.o'
    return env.Object(os.path.join(builddir, objname), src)

def BuilddirProgram(env, builddir, prog, deps):
    p = env.Program(os.path.join(builddir, prog), deps)
    Depends(p, link_script)
    # TODO: not sure that hardcoding the 'bin' action below is a good idea
    return env.Bin(p)

# TODO: does executables below need to be global (exported)?
executables = []
Export('BuilddirObject BuilddirProgram executables')

colors = {}
colors['cyan']   = '\\033[96m'
colors['purple'] = '\\033[95m'
colors['blue']   = '\\033[94m'
colors['green']  = '\\033[92m'
colors['yellow'] = '\\033[93m'
colors['red']    = '\\033[91m'
colors['end']    = '\\033[0m'

#If the output is not a terminal, remove the colors
if not sys.stdout.isatty():
   for key, value in colors.iteritems():
      colors[key] = ''

compile_source_message = '%s[COMPILE] %s$SOURCE%s' % (colors['blue'], colors['yellow'], colors['end'])
assemble_source_message = '%s[ASSEMBLE] %s$SOURCE%s' % (colors['purple'], colors['yellow'], colors['end'])
link_program_message = '%s[LINK] %s$TARGET%s' % (colors['red'], colors['yellow'], colors['end'])
link_library_message = '%s[LIBRARY] %s$TARGET%s' % (colors['cyan'], colors['yellow'], colors['end'])

env['CXXCOMSTR'] = compile_source_message
env['CCCOMSTR'] = compile_source_message
env['ASCOMSTR'] = assemble_source_message
env['ASPPCOMSTR'] = assemble_source_message
env['ARCOMSTR'] = link_library_message
env['LINKCOMSTR'] = link_program_message

{% else %}

Import('env')

# Clone the parent env. We use the clone to keep the settings which are specific
# to this module (most notably the include path)
env = env.Clone()

{% endif %}

includes = []
objects = []

# include root directories of all components we depend on (directly and
# indirectly, including ourself)
{{ include_root_dirs }}

# recurse into dependencies that aren't built elsewhere
{{ add_depend_subdirs }}

# TODO:handle include_sys_dirs

{% if include_other_dirs %}
# And others (typically CMSIS implementations) need to export non-system header
# files. Please don't use this facility. Please. It's much, much better to fix
# implementations that import these headers to import them using the full path.
{{ include_other_dirs }}
{% endif %}

# TODO: handle set_objc_flags

# Build targets may define additional preprocessor definitions for all
# components to use (such as chip variant information)
defs = []
{{ yotta_target_definitions }}

# Provide the version of the component being built, in case components want to
# embed this into compiled libraries
defs.append(('YOTTA_COMPONENT_VERSION', '\\\\"{{ component_version }}\\\\"'))

env.AppendUnique(CPPPATH = includes, CPPDEFINES = defs)

# recurse into subdirectories for this component, using the two-argument
# add_subdirectory because the directories referred to here exist in the source
# tree, not the working directory
{% if toplevel %}
env['builddir'] = env['buildroot']
{% else %}
env['builddir'] = os.path.join(env['buildroot'], "ym", "{{ component_name }}")
{% endif %}

{% for srcdir, workingdir in add_own_subdirs %}
objects.append(SConscript(
    "{{ workingdir | replaceBackslashes }}/SConscript",
    exports = 'env objects'
    ) or [])
{% endfor %}

{% if topdir %}
Default(executables)
{% else %}
Return('objects')
{% endif %}
'''

Subdir_SCons_Template = '''
# NOTE: This file is generated by yotta: changes will be overwritten!
import os

Import('env')

# Clone the parent env. We use the clone to keep the settings which are specific
# to this module (most notably the include path)
env = env.Clone()
{% if executable %}
Import('objects executables')
{% else %}
objects = []
{% endif %}

env.AppendUnique(CPPPATH = "{{ source_directory | replaceBackslashes }}")
Import('BuilddirObject BuilddirProgram')
builddir = os.path.join(env['builddir'], "{{ subdir_name }}")

{% for file_name, language in source_files %}
objects.append(BuilddirObject(env, builddir, "{{ file_name | replaceBackslashes }}"))
{% endfor %}

# TODO: handle resource files

{% if executable %}
executables.append(BuilddirProgram(env, builddir, "{{ object_name }}", objects))
{% else %}
Return('objects')
{% endif %}

# TODO: handle resource files

#TODO: handle library

#TODO: post build

#TODO: handle resource files

#TODO: handle ObjC/plist

'''

#this is a jinja2 template
Test_SCons_Template = '''
# NOTE: This file is generated by yotta: changes will be overwritten!
import os
Import('env BuilddirProgram BuilddirObject')
env = env.Clone()
Import('objects executables')
env.AppendUnique(CPPPATH = "{{ source_directory | replaceBackslashes }}")

# TODO: replaceBackslashes below!
{% for file_names, object_name, languages in tests %}
testobjs = []
testbuild = os.path.join(env['builddir'], "test", "{{ object_name }}")
{% for file_name in file_names %}
testobjs.append(BuilddirObject(env, testbuild, "{{ file_name }}"))
{% endfor %}
executables.append(BuilddirProgram(env, testbuild, "{{ object_name }}", testobjs + objects)) 

# TODO: handle ObjC
# TODO: handle post-build steps

{% endfor %}
'''

logger = logging.getLogger('sconsgen')

Ignore_Subdirs = set(('build','yotta_modules', 'yotta_targets'))

templates = {
    'base': SCons_Template,
    'subdir': Subdir_SCons_Template,
    'test': Test_SCons_Template
}
jinja_environment = Environment(loader=DictLoader(templates), trim_blocks=True, lstrip_blocks=True)

def replaceBackslashes(s):
    return s.replace('\\', '/')
jinja_environment.filters['replaceBackslashes'] = replaceBackslashes

class SourceFile(object):
    def __init__(self, fullpath, relpath, lang):
        super(SourceFile, self).__init__()
        self.fullpath = fullpath
        self.relpath = relpath
        self.lang = lang
    def __repr__(self):
        return self.fullpath

class SConsGen(object):
    def __init__(self, directory, target):
        super(SConsGen, self).__init__()
        self.buildroot = directory
        logger.info("generate for target: %s" % target)
        self.target = target

    def _writeFile(self, path, contents):
        dirname = os.path.dirname(path)
        fsutils.mkDirP(dirname)
        self.writeIfDifferent(path, contents)

    def generateRecursive(self, component, all_components, builddir=None, modbuilddir=None, processed_components=None):
        ''' generate top-level SConstruct/SConscript for this component and its
            dependencies: the SConstruct/SConscript files are all generated in self.buildroot,
            which MUST be out-of-source

            !!! NOTE: experimenting with a slightly different way of doing
            things here, this function is a generator that yields any errors
            produced, so the correct use is:

            for error in gen.generateRecursive(...):
                print(error)
        '''
        if builddir is None:
            builddir = self.buildroot
        if modbuilddir is None:
            modbuilddir = os.path.join(builddir, 'ym')
        if processed_components is None:
            processed_components = dict()
        if not self.target:
            yield 'Target "%s" is not a valid build target' % self.target

        toplevel = not len(processed_components)

        logger.debug('generate build files: %s (target=%s)' % (component, self.target))
        # because of the way c-family language includes work we need to put the
        # public header directories of all components that this component
        # depends on (directly OR indirectly) into the search path, which means
        # we need to first enumerate all the direct and indirect dependencies
        recursive_deps = component.getDependenciesRecursive(
            available_components = all_components,
                          target = self.target,
                  available_only = True
        )
        dependencies = component.getDependencies(
                  all_components,
                          target = self.target,
                  available_only = True
        )

        for name, dep in dependencies.items():
            if not dep:
                yield 'Required dependency "%s" of "%s" is not installed.' % (name, component)
        # ensure this component is assumed to have been installed before we
        # check for its dependencies, in case it has a circular dependency on
        # itself
        processed_components[component.getName()] = component
        new_dependencies = {name:c for name,c in dependencies.items() if c and not name in processed_components}
        self.generate(builddir, modbuilddir, component, new_dependencies, dependencies, recursive_deps, toplevel)

        logger.debug('recursive deps of %s:' % component)
        for d in recursive_deps.values():
            logger.debug('    %s' % d)

        processed_components.update(new_dependencies)
        for name, c in new_dependencies.items():
            for error in self.generateRecursive(
                c, all_components, os.path.join(modbuilddir, name), modbuilddir, processed_components
            ):
                yield error

    def checkStandardSourceDir(self, dirname, component):
        err = validate.sourceDirValidationError(dirname, component.getName())
        if err:
            logger.warn(err)

    def _sanitizeTarget(self, targetname):
        return re.sub('[^a-zA-Z0-9]', '_', targetname).upper()

    def _sanitizeSymbol(self, sym):
        return re.sub('[^a-zA-Z0-9]', '_', sym)

    def _listSubDirectories(self, component):
        ''' return: {
                manual: [list of subdirectories with manual SConscript],
                  auto: [list of pairs: (subdirectories name to autogenerate, a list of source files in that dir)],
                   bin: {dictionary of subdirectory name to binary name},
                  test: [list of directories that build tests]
              resource: [list of directories that contain resources]
            }
        '''
        manual_subdirs = []
        auto_subdirs = []
        bin_subdirs = {os.path.normpath(x) : y for x,y in component.getBinaries().items()};
        test_subdirs = []
        resource_subdirs = []
        for f in os.listdir(component.path):
            if f in Ignore_Subdirs or f.startswith('.') or f.startswith('_'):
                continue
            if os.path.isfile(os.path.join(component.path, f, 'SConscript')):
                self.checkStandardSourceDir(f, component)
                # if the subdirectory has a SConscript in it, then use that
                manual_subdirs.append(os.path.join(component.path, f))
                # tests only supported in the `test` directory for now
                if f in ('test',):
                    test_subdirs.append(f)
            elif f in ('source', 'test') or os.path.normpath(f) in bin_subdirs:
                # otherwise, if the directory has source files, generate a
                # SConscript in the corresponding temporary directory, and add
                # that.
                # For now we only do this for the source and test directories -
                # in theory we could do others
                sources = self.containsSourceFiles(os.path.join(component.path, f), component)
                if sources:
                    auto_subdirs.append((f, sources))
                    # tests only supported in the `test` directory for now
                    if f in ('test',):
                        test_subdirs.append(f)
            elif f in ('resource'):
                resource_subdirs.append(os.path.join(component.path, f))
            elif f.lower() in ('source', 'src', 'test', 'resource'):
                self.checkStandardSourceDir(f, component)
        return {
            "manual": manual_subdirs,
              "auto": auto_subdirs,
               "bin": bin_subdirs,
              "test": test_subdirs,
          "resource": resource_subdirs
        }

    def generate(self, builddir, modbuilddir, component, active_dependencies, immediate_dependencies, all_dependencies, toplevel):
        ''' active_dependencies is the dictionary of components that need to be
            built for this component, but will not already have been built for
            another component.
        '''

        include_own_dir = 'include_directories("%s")\n' % component.path

        include_root_dirs = ''
        include_sys_dirs = ''
        include_other_dirs = ''
        objc_flags_set = {}
        objc_flags = []
        for name, c in itertools.chain(((component.getName(), component),), all_dependencies.items()):
            include_root_dirs += 'includes.append("%s")\n' % replaceBackslashes(c.path)
            dep_sys_include_dirs = c.getExtraSysIncludes()
            for d in dep_sys_include_dirs:
                include_sys_dirs += 'include_directories(SYSTEM "%s")\n' % replaceBackslashes(os.path.join(c.path, d))
            dep_extra_include_dirs = c.getExtraIncludes()
            for d in dep_extra_include_dirs:
                include_other_dirs += 'includes.append("%s")\n' % replaceBackslashes(os.path.join(c.path, d))
        for name, c in list(all_dependencies.items()) + [(component.getName(), component)]:
            dep_extra_objc_flags = c.getExtraObjcFlags()
            # Try to warn Geraint when flags are clobbered. This will probably
            # miss some obscure flag forms, but it tries pretty hard
            for f in dep_extra_objc_flags:
                flag_name = None
                if len(f.split('=')) == 2:
                    flag_name = f.split('=')[0]
                elif f.startswith('-fno-'):
                    flag_name = f[5:]
                elif f.startswith('-fno'):
                    flag_name = f[4:]
                elif f.startswith('-f'):
                    flag_name = f[2:]
                if flag_name is not None:
                    if flag_name in objc_flags_set and objc_flags_set[flag_name] != name:
                        logger.warning(
                            'component %s Objective-C flag "%s" clobbers a value earlier set by component %s' % (
                            name, f, objc_flags_set[flag_name]
                        ))
                    objc_flags_set[flag_name] = name
                objc_flags.append(f)
        set_objc_flags = ' '.join(objc_flags)

        add_depend_subdirs = ''
        for name, c in active_dependencies.items():
            depend_subdir = replaceBackslashes(os.path.join(modbuilddir, name))
            # TODO change below
            add_depend_subdirs += 'objects.append(SConscript("%s", exports = "env objects"))\n' % (os.path.join(depend_subdir, 'SConscript'))

        subdirs = self._listSubDirectories(component)
        manual_subdirs      = subdirs['manual']
        autogen_subdirs     = subdirs['auto']
        binary_subdirs      = subdirs['bin']
        test_subdirs        = subdirs['test']
        resource_subdirs    = subdirs['resource']

        add_own_subdirs = []
        for f in manual_subdirs:
            if os.path.isfile(os.path.join(component.path, f, 'SConscript')):
                add_own_subdirs.append(
                    (os.path.join(component.path, f), os.path.join(builddir, f))
                )

        # names of all directories at this level with stuff in: used to figure
        # out what to link automatically
        all_subdirs = manual_subdirs + [x[0] for x in autogen_subdirs]
        for f, source_files in autogen_subdirs:
            if f in binary_subdirs:
                exe_name = binary_subdirs[f]
            else:
                exe_name = None
            if f in test_subdirs:
                self.generateTestDirList(
                    builddir, f, source_files, component, immediate_dependencies
                )
            else:
                self.generateSubDirList(
                    builddir, f, source_files, component, all_subdirs,
                    immediate_dependencies, exe_name, resource_subdirs
                )
            add_own_subdirs.append(
                (os.path.join(builddir, f), os.path.join(builddir, f))
            )

        target_definitions = 'defs.append(("TARGET", "%s"))\n' % self._sanitizeTarget(self.target.getName())
        set_targets_like = 'set(TARGET_LIKE_' + self._sanitizeTarget(self.target.getName()) + ' TRUE)\n'
        for target in self.target.dependencyResolutionOrder():
            if '*' not in target:
                target_definitions += 'defs.append("TARGET_LIKE_%s")\n' % self._sanitizeTarget(target)
                set_targets_like += 'set(TARGET_LIKE_' + self._sanitizeTarget(target) + ' TRUE)\n'

        template = jinja_environment.get_template('base')
        file_contents = template.render({
                            "toplevel": toplevel,
                         "target_name": self.target.getName(),
                    "set_targets_like": set_targets_like,
                      "toolchain_file": self.target.getToolchainFile(),
                      "component_name": component.getName(),
                     "include_own_dir": include_own_dir,
                   "include_root_dirs": include_root_dirs,
                    "include_sys_dirs": include_sys_dirs,
                  "include_other_dirs": include_other_dirs,
                      "set_objc_flags": set_objc_flags,
                  "add_depend_subdirs": add_depend_subdirs,
                     "add_own_subdirs": add_own_subdirs,
            "yotta_target_definitions": target_definitions,
                   "component_version": component.getVersion(),
                           "build_dir": builddir
        })
        self._writeFile(os.path.join(builddir, 'SConstruct' if toplevel else 'SConscript'), file_contents)

    def writeIfDifferent(self, fname, contents):
        try:
            with open(fname, "r+") as f:
                current_contents = f.read()
                if current_contents != contents:
                    f.seek(0)
                    f.write(contents)
                    f.truncate()
        except IOError:
            with open(fname, "w") as f:
                f.write(contents)

    def generateTestDirList(self, builddir, dirname, source_files, component, immediate_dependencies):
        logger.debug('generate SConscript for directory: %s' % os.path.join(component.path, dirname))

        link_dependencies = [x for x in immediate_dependencies]
        fname = os.path.join(builddir, dirname, 'SConscript')

        # group the list of source files by subdirectory: generate one test for
        # each subdirectory, and one test for each file at the top level
        subdirs = defaultdict(list)
        toplevel_srcs = []
        for f in source_files:
            if f.lang in ('c', 'cpp', 'objc'):
                subrelpath = os.path.relpath(f.relpath, dirname)
                subdir = os.path.split(subrelpath)[0]
                if subdir:
                    subdirs[subdir].append(f)
                else:
                    toplevel_srcs.append(f)

        tests = []
        for f in toplevel_srcs:
            object_name = '%s-test-%s' % (
                component.getName(), os.path.basename(os.path.splitext(str(f))[0]).lower()
            )
            tests.append([[str(f)], object_name, [f.lang]])
        for subdirname, sources in subdirs.items():
            object_name = '%s-test-%s' % (
                component.getName(), fsutils.fullySplitPath(subdirname)[0].lower()
            )
            tests.append([[str(f) for f in sources], object_name, [f.lang for f in sources]])

        # link tests against the main executable
        link_dependencies.append(component.getName())

        test_template = jinja_environment.get_template('test')

        file_contents = test_template.render({
             'source_directory':os.path.join(component.path, dirname),
                        'tests':tests,
            'link_dependencies':link_dependencies
        })

        self._writeFile(fname, file_contents)

    def generateSubDirList(self, builddir, dirname, source_files, component, all_subdirs, immediate_dependencies, executable_name, resource_subdirs):
        logger.debug('generate SConscript for directory: %s' % os.path.join(component.path, dirname))

        link_dependencies = [x for x in immediate_dependencies]
        fname = os.path.join(builddir, dirname, 'SConscript')

        if dirname == 'source' or executable_name:
            if executable_name:
                object_name = executable_name
                executable  = True
            else:
                object_name = component.getName()
                executable  = False
            # if we're building the main library, or an executable for this
            # component, then we should link against all the other directories
            # containing SConscript:
            link_dependencies += [x for x in all_subdirs if x not in ('source', 'test', dirname)]

            # Find resource files
            resource_files = []
            for f in resource_subdirs:
                for root, dires, files in os.walk(f):
                    for f in files:
                        resource_files.append(os.path.join(root, f))

            subdir_template = jinja_environment.get_template('subdir')

            file_contents = subdir_template.render({
                    'source_directory': os.path.join(component.path, dirname),
                          'executable': executable,
                          'file_names': [os.path.join(builddir, 'test', str(f)) for f in source_files],
                         'object_name': object_name,
                   'link_dependencies': link_dependencies,
                           'languages': set(f.lang for f in source_files),
                        'source_files': set((f.fullpath, f.lang) for f in source_files),
                      "resource_files": resource_files,
                         "subdir_name": dirname,
                           "component": component.getName()
            })
        else:
            raise Exception('auto SConscript for non-source/test directories is not supported')
        self._writeFile(fname, file_contents)


    def containsSourceFiles(self, directory, component):
        c_exts          = set(('.c',))
        cpp_exts        = set(('.cpp','.cc','.cxx'))
        objc_exts       = set(('.m', '.mm'))
        plist_exts      = set(('.plist',))
        asm_exts        = set(('.s',))

        sources = []
        for root, dires, files in os.walk(directory):
            for f in files:
                name, ext = os.path.splitext(f)
                ext = ext.lower()
                fullpath = os.path.join(root, f)
                relpath  = os.path.relpath(fullpath, component.path)
                if component.ignores(relpath):
                    continue
                if ext in c_exts:
                    sources.append(SourceFile(fullpath, relpath, 'c'))
                elif ext in cpp_exts:
                    sources.append(SourceFile(fullpath, relpath, 'cpp'))
                elif ext in objc_exts:
                    sources.append(SourceFile(fullpath, relpath, 'objc'))
                elif ext in plist_exts:
                    sources.append(SourceFile(fullpath, relpath, 'plist'))
                elif ext in asm_exts:
                    sources.append(SourceFile(fullpath, relpath, 'asm'))
        return sources
